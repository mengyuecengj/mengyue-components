import{_ as e,c as a,o as l,ah as r}from"./chunks/framework.D3tsReks.js";const g=JSON.parse('{"title":"💡 组件设计理念","description":"","frontmatter":{},"headers":[],"relativePath":"design/FastRead.md","filePath":"design/FastRead.md"}'),t={name:"design/FastRead.md"};function n(i,o,s,c,p,d){return l(),a("div",null,[...o[0]||(o[0]=[r('<h1 id="💡-组件设计理念" tabindex="-1">💡 组件设计理念 <a class="header-anchor" href="#💡-组件设计理念" aria-label="Permalink to “💡 组件设计理念”">​</a></h1><blockquote><p><strong>mengyue-components</strong> 不是在“造组件”，而是在“提炼思想”。 希望通过可复用的结构、语义化的设计、统一的逻辑模型，让前端开发从“堆代码”走向“构建系统”。 设计的理念从来都是: 用最少的代码实现最丰富与复杂的功能。</p></blockquote><p>这并非介绍组件内容，而是记录整个组件库设计过程中的 <strong>思考逻辑与哲学原则</strong>。<br> 所以所阐述的不是“某个组件如何用”，而是“为什么存在这个组件”与“如何设计这个组件”等。</p><h2 id="🧭-设计的起点-从问题出发" tabindex="-1">🧭 设计的起点：从问题出发 <a class="header-anchor" href="#🧭-设计的起点-从问题出发" aria-label="Permalink to “🧭 设计的起点：从问题出发”">​</a></h2><p>每一个组件的诞生都源于一个“痛点”。 在实际项目中，我们遇到的挑战不是“缺少组件”，而是“缺少一套连贯的解决方案”。 因此，这个库的设计从来不是堆叠功能，而是基于以下两个问题展开：</p><ol><li><strong>什么是真正通用的抽象？</strong><br> 我们要让组件能在多项目中重用，而不是一次性产物。</li><li><strong>如何让交互逻辑与视觉表现解耦？</strong><br> 这样，组件才能在不同主题、平台或交互层中复用。</li></ol><p>换言之，每个组件的出现都是“问题驱动”的。<br> 没有凭空的设计，只有针对性的解法。</p><h2 id="🧩-抽象的边界-设计不是创造-而是取舍" tabindex="-1">🧩 抽象的边界：设计不是创造，而是取舍 <a class="header-anchor" href="#🧩-抽象的边界-设计不是创造-而是取舍" aria-label="Permalink to “🧩 抽象的边界：设计不是创造，而是取舍”">​</a></h2><p>组件的设计核心不在“能做什么”，而在“<strong>不做什么</strong>”。<br> 过度封装会让组件变得臃肿，而过度抽象又会失去使用价值。</p><p><code>mengyue-components</code> 的策略是——在每个组件的生命周期中明确三层边界：</p><ul><li><strong>结构边界</strong>：只定义基础结构，不干涉用户的业务样式。</li><li><strong>逻辑边界</strong>：仅负责组件内的逻辑，不承担外部状态。</li><li><strong>扩展边界</strong>：留出插槽与事件接口，让外部有空间去“再设计”。</li></ul><blockquote><p>设计的成熟，不是功能多，而是知道哪里该停。</p></blockquote><h2 id="🧠-组件的哲学-从-零件-到-语言" tabindex="-1">🧠 组件的哲学：从“零件”到“语言” <a class="header-anchor" href="#🧠-组件的哲学-从-零件-到-语言" aria-label="Permalink to “🧠 组件的哲学：从“零件”到“语言””">​</a></h2><p>在设计初期，发现一个关键问题：如果组件只是“零件”，那么它只能被机械的拼装。但如果它能成为“语言”，那开发者就能用它去“表达思想”。</p><p>于是我们确立了一个目标：让每个组件都具备 <strong>语义一致性</strong> 和 <strong>可组合性</strong>， 使它们能像句子一样组合出复杂的逻辑与交互。 这种理念促成了三个设计原则：</p><ol><li><strong>一切都是表达</strong>：按钮不是点击器，而是动作的声明。</li><li><strong>一切都可组合</strong>：组件不是黑盒，而是拼图的一块。</li><li><strong>一切皆有语义</strong>：组件的命名、属性、行为都要服务于清晰表达。</li></ol><h2 id="⚙️-从视觉到逻辑的-层分离-思想" tabindex="-1">⚙️ 从视觉到逻辑的“层分离”思想 <a class="header-anchor" href="#⚙️-从视觉到逻辑的-层分离-思想" aria-label="Permalink to “⚙️ 从视觉到逻辑的“层分离”思想”">​</a></h2><p>传统 UI 组件库往往把“视觉 + 逻辑”绑定在一起，这会导致复用性差。所以会拆解出三个平行层次：</p><ol><li><strong>结构层（Structure Layer）</strong>：组件的基础 DOM 和可交互区域。</li><li><strong>逻辑层（Logic Layer）</strong>：通过 Composition API 管理内部状态与事件流。</li><li><strong>表现层（Presentation Layer）</strong>：基于 Token 的统一样式系统，负责视觉统一。</li></ol><p>这样设计的意义是：</p><blockquote><p>当样式变化时，不必修改逻辑； 当逻辑变化时，不必破坏结构。</p></blockquote><p>这种清晰的层次划分，保证了组件在复杂项目中的可维护性与长期演进能力。</p><h2 id="🧭-状态与可控性-让组件-听话-但不-死板" tabindex="-1">🧭 状态与可控性：让组件“听话”但不“死板” <a class="header-anchor" href="#🧭-状态与可控性-让组件-听话-但不-死板" aria-label="Permalink to “🧭 状态与可控性：让组件“听话”但不“死板””">​</a></h2><p>组件既要能自动运作，也要能被完全控制。因此在设计时，我们强调“<strong>可控与非可控并存</strong>”的理念。</p><ul><li><strong>非可控模式</strong>：用户只传入最小必要配置，组件自动处理内部状态。</li><li><strong>可控模式</strong>：通过 v-model/modelValue、事件回调等机制，让用户接管内部逻辑。</li></ul><p>这种双向模式，使得组件既能“即插即用”，又能“深度定制”。<br> 我们称这种模式为 <strong>「渐进式可控」</strong> —— 开发者只需按需介入复杂度。</p><h2 id="🔄-组合式逻辑与可扩展架构" tabindex="-1">🔄 组合式逻辑与可扩展架构 <a class="header-anchor" href="#🔄-组合式逻辑与可扩展架构" aria-label="Permalink to “🔄 组合式逻辑与可扩展架构”">​</a></h2><p>随着 Vue 3 的 Composition API 普及，我们将逻辑复用视为核心竞争力。<code>mengyue-components</code> 的内部逻辑几乎全部采用组合式封装：</p><ul><li>通用的状态逻辑被抽离为 Hooks（如 <code>useVisible</code>、<code>useKeyboard</code>、<code>useTheme</code>）。</li><li>组件间通过自定义事件与上下文通信，避免强依赖。</li><li>插件机制允许开发者以统一入口扩展功能，而无需修改源码。</li></ul><blockquote><p>组件库不是封闭系统，而是可生长的生态。</p></blockquote><h2 id="🧩-可访问性与交互伦理" tabindex="-1">🧩 可访问性与交互伦理 <a class="header-anchor" href="#🧩-可访问性与交互伦理" aria-label="Permalink to “🧩 可访问性与交互伦理”">​</a></h2><p>一个现代组件库必须考虑 <strong>Accessibility（可访问性）</strong>。<br> 设计理念是：“交互不只是视觉体验，更是包容性的设计。”</p><ul><li>所有交互元素都具备键盘操作与 ARIA 属性。</li><li>动画节奏遵循“感知舒适原则”，避免突兀与强闪烁。</li><li>错误提示与状态变化都有非视觉信号（如语音辅助或焦点移动）。</li></ul><blockquote><p>技术的温度，来自设计的体贴。</p></blockquote><h2 id="🧾-从工具到思想" tabindex="-1">🧾 从工具到思想 <a class="header-anchor" href="#🧾-从工具到思想" aria-label="Permalink to “🧾 从工具到思想”">​</a></h2><p>回顾整个设计过程，我们并没有在追求“更多的组件”，而是在追求“更好的表达方式”。</p><p><strong>mengyue-components</strong> 的意义，在于：</p><ul><li>建立一套能被理解、被继承、被改造的设计语言；</li><li>让每一个组件都具备清晰的边界与目的；</li><li>让“组件化”不只是工程手段，而是思考问题的方式。</li></ul><blockquote><p>💬 “创造的从不是按钮、表格或弹窗，而是前端表达的语法。”<br> 当开发者开始用这套语言说话时，组件库的设计就真正完成了。</p></blockquote><h2 id="说明" tabindex="-1">说明 <a class="header-anchor" href="#说明" aria-label="Permalink to “说明”">​</a></h2><blockquote><p>一些组件库的的设计有一定程度用了hooks或者工具函数，在阅读前需要了解这些函数的含义。</p></blockquote>',41)])])}const b=e(t,[["render",n]]);export{g as __pageData,b as default};
