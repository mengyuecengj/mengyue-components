import{_ as o,c as a,o as t,ah as l}from"./chunks/framework.BWIYv-lY.js";const u=JSON.parse('{"title":"🧩 组件库研发","description":"","frontmatter":{},"headers":[],"relativePath":"development/preface.md","filePath":"development/preface.md"}'),i={name:"development/preface.md"};function r(d,e,s,n,c,p){return t(),a("div",null,[...e[0]||(e[0]=[l('<h1 id="🧩-组件库研发" tabindex="-1">🧩 组件库研发 <a class="header-anchor" href="#🧩-组件库研发" aria-label="Permalink to “🧩 组件库研发”">​</a></h1><p>在构建 <strong>mengyue-components</strong> 之初希望这不仅仅是一个 UI 集合，而是一套完整的、可持续演化的组件生态。 每一个按钮、每一段动画、每一条工具函数，背后都承载着「抽象、统一、可复用」的设计哲学。</p><h2 id="✨-设计初衷" tabindex="-1">✨ 设计初衷 <a class="header-anchor" href="#✨-设计初衷" aria-label="Permalink to “✨ 设计初衷”">​</a></h2><p>在众多 UI 库中，往往组件繁多但抽象层次混乱。我们希望通过更精细的“核心分层架构”来实现高内聚、低耦合：</p><ul><li><strong>视觉与逻辑解耦</strong>：组件关注交互与表现，逻辑独立为 composables 或 hooks。</li><li><strong>轻量与可控</strong>：一切能力可按需引入，不浪费字节。</li><li><strong>从复用到演化</strong>：组件不仅能复用，还能成为业务中台 UI 的「构建基石」。</li></ul><h2 id="🧠-核心函数设计理念" tabindex="-1">🧠 核心函数设计理念 <a class="header-anchor" href="#🧠-核心函数设计理念" aria-label="Permalink to “🧠 核心函数设计理念”">​</a></h2><p>核心函数是组件行为的底层基石。例如：</p><ul><li>状态控制逻辑，如 <code>useToggle</code>、<code>useVisible</code>；</li><li>动画状态驱动，如 <code>useTransition</code>；</li><li>DOM 事件封装，如 <code>useClickOutside</code>；</li><li>核心工具，如 <code>createNamespace</code>、<code>composeProps</code>。</li></ul><p>我们在设计这些函数时遵循三条原则：</p><ol><li><strong>独立性</strong>：每个函数必须可以脱离组件使用；</li><li><strong>组合性</strong>：多个 hook 可以在一个组件内部组合使用；</li><li><strong>可测试性</strong>：所有逻辑均具备独立单元测试用例。</li></ol><h2 id="⚙️-核心实现思路" tabindex="-1">⚙️ 核心实现思路 <a class="header-anchor" href="#⚙️-核心实现思路" aria-label="Permalink to “⚙️ 核心实现思路”">​</a></h2><h3 id="🧩-模块分层架构" tabindex="-1">🧩 模块分层架构 <a class="header-anchor" href="#🧩-模块分层架构" aria-label="Permalink to “🧩 模块分层架构”">​</a></h3><p>我们将组件库逻辑分为 4 层：</p><table tabindex="0"><thead><tr><th>层级</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>View 层</td><td>组件模板与样式</td><td><code>button.vue</code>、<code>dialog.vue</code></td></tr><tr><td>Logic 层</td><td>状态与交互逻辑</td><td><code>useButton()</code>、<code>useDialog()</code></td></tr><tr><td>Utils 层</td><td>通用工具与辅助函数</td><td><code>dom.ts</code>、<code>event.ts</code></td></tr><tr><td>Core 层</td><td>框架核心定义</td><td><code>install.ts</code>、<code>createComponent.ts</code></td></tr></tbody></table><p>这种结构让组件既能独立开发，也能在系统层面统一维护。</p><h2 id="🪝-hooks-的设计哲学" tabindex="-1">🪝 Hooks 的设计哲学 <a class="header-anchor" href="#🪝-hooks-的设计哲学" aria-label="Permalink to “🪝 Hooks 的设计哲学”">​</a></h2><p>Hooks 是组件库的灵魂。 在 mengyue-components 中定义了三类 hooks：</p><ul><li>逻辑类 Hooks：负责数据与状态，如 useFormState、usePagination。</li><li>交互类 Hooks：负责 DOM 与用户事件，如 useHover、useResizeObserver。</li><li>系统类 Hooks：如 useZIndex、useGlobalConfig，负责跨组件协调。</li></ul><blockquote><p>“一个 Hook 只做一件事，并且可在任何地方独立使用。” 这意味着每一个组件的核心，都能通过 Hooks 被抽离、替换或二次封装。</p></blockquote><h2 id="📦-打包与体积优化" tabindex="-1">📦 打包与体积优化 <a class="header-anchor" href="#📦-打包与体积优化" aria-label="Permalink to “📦 打包与体积优化”">​</a></h2><p>为了让包更小，我们在构建层面做了多层优化：</p><ul><li><p>按需打包: 使用 vite-plugin-dts + unplugin-vue-components 实现自动导入与类型生成；</p></li><li><p>Tree-shaking 彻底: 所有导出均为 ESM 格式，确保未使用的逻辑不会进入最终包；</p></li><li><p>样式隔离与复用: 采用 CSS Variables 实现主题动态切换，减少冗余样式；</p></li><li><p>构建分析: 集成 rollup-plugin-visualizer 定期分析体积结构；</p></li><li><p>压缩与代码分块: 按功能拆分 chunk 并使用 gzip/br 压缩，减少首屏负担。</p></li></ul><p>在最终产物中，一个完整组件平均仅占 2~5KB（gzipped），性能与灵活性并存。</p><h2 id="🧭-架构演进与未来计划" tabindex="-1">🧭 架构演进与未来计划 <a class="header-anchor" href="#🧭-架构演进与未来计划" aria-label="Permalink to “🧭 架构演进与未来计划”">​</a></h2><p>组件库不是一次性产物，而是长期演化的结果。接下来将继续：</p><p>重点优化 hooks 类型系统，提升开发智能提示体验；</p><p>拓展 Theme 主题系统，支持动态主题与多品牌皮肤等等；</p><h2 id="🌌-结语" tabindex="-1">🌌 结语 <a class="header-anchor" href="#🌌-结语" aria-label="Permalink to “🌌 结语”">​</a></h2><p>一个优秀的组件库，不是堆砌组件的合集，而是抽象与设计思维的沉淀。 mengyue-components 的目标，不仅是帮助开发者“写得快”，更是“写得稳、写得久、写得优雅”。</p><p>✨ “代码的美，在于抽象的克制与设计的秩序。”</p>',30)])])}const m=o(i,[["render",r]]);export{u as __pageData,m as default};
