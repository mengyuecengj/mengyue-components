import{_ as e,o as t,c as d,ah as r}from"./chunks/framework.BzrxsKI0.js";const h=JSON.parse('{"title":"useColorComputed","description":"","frontmatter":{},"headers":[],"relativePath":"design/hooks/useColor.md","filePath":"design/hooks/useColor.md"}'),a={name:"design/hooks/useColor.md"};function l(s,o,c,i,n,p){return t(),d("div",null,[...o[0]||(o[0]=[r('<h1 id="usecolorcomputed" tabindex="-1">useColorComputed <a class="header-anchor" href="#usecolorcomputed" aria-label="Permalink to “useColorComputed”">​</a></h1><h2 id="usecolorcomputed-颜色与状态样式计算-hook" tabindex="-1">useColorComputed：颜色与状态样式计算 Hook <a class="header-anchor" href="#usecolorcomputed-颜色与状态样式计算-hook" aria-label="Permalink to “useColorComputed：颜色与状态样式计算 Hook”">​</a></h2><h2 id="痛点来源" tabindex="-1">痛点来源 <a class="header-anchor" href="#痛点来源" aria-label="Permalink to “痛点来源”">​</a></h2><p>在 UI 组件（如 Button、Tag、Badge 等）中，颜色与交互状态的样式处理往往是最复杂的重复逻辑之一：</p><ul><li>需要支持自定义 <code>colorBg</code>、<code>colorText</code>、<code>colorBorder</code></li><li><code>plain</code>（朴素）模式下，背景、文字、边框需根据类型（如 primary、success）使用主题变量，并处理透明度</li><li>不同交互状态（hover、active）需要动态切换颜色</li><li>禁用状态下颜色需统一为透明 + 固定文字/边框色</li><li>颜色格式可能为变量（如 <code>var(--el-color-primary)</code>），需支持透明度转换（如 <code>rgba(var(...), 0.2)</code>）</li></ul><p>若每个组件都自行实现这些规则，不仅逻辑冗余，还极易导致视觉不一致、主题切换失效、暗色模式适配困难等问题。</p><h2 id="设计目标" tabindex="-1">设计目标 <a class="header-anchor" href="#设计目标" aria-label="Permalink to “设计目标”">​</a></h2><p><code>useColorComputed</code> 的目标是：<strong>集中统一处理所有组件的颜色与状态样式逻辑</strong>，提供一套响应式、可配置、与主题系统深度集成的内联样式计算方案，让组件只需传入少数颜色相关 props，即可获得完整的视觉状态表现。</p><h2 id="核心特性" tabindex="-1">核心特性 <a class="header-anchor" href="#核心特性" aria-label="Permalink to “核心特性”">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>响应式样式输出</strong></td><td>返回 <code>ComputedRef&lt;CSSProperties&gt;</code>，支持 Ref 类型的 <code>isHovered</code>/<code>isActive</code> 实时响应</td></tr><tr><td><strong>完整状态覆盖</strong></td><td>优先处理 <code>disabled</code> → <code>plain</code> → 自定义颜色 → 基础 fallback，逻辑清晰不冲突</td></tr><tr><td><strong>plain 模式智能处理</strong></td><td>区分 <code>default</code> 类型与有色类型（如 primary），自动使用主题变量并处理 hover/active 切换与透明度</td></tr><tr><td><strong>主题变量深度支持</strong></td><td>通过 <code>useColorUtils.toRGBA</code> 实现 <code>var(--xxx)</code> 的透明度转换，确保与 CSS 变量系统无缝协作</td></tr><tr><td><strong>自定义颜色优先</strong></td><td>当传入 <code>colorBg</code>、<code>colorText</code>、<code>colorBorder</code> 时，直接覆盖主题逻辑，支持完全自由定制</td></tr><tr><td><strong>禁用状态统一</strong></td><td>固定为透明背景 + 白色文字/边框，视觉一致性强</td></tr><tr><td><strong>类型安全</strong></td><td>通过 <code>ColorComputedProps</code> 接口明确约束 props，支持 TypeScript 完整推导</td></tr></tbody></table><h2 id="设计价值" tabindex="-1">设计价值 <a class="header-anchor" href="#设计价值" aria-label="Permalink to “设计价值”">​</a></h2><p>useColorComputed 是组件库中视觉统一性的关键一环，它与 useClassComputed、useStyleComputed 共同构成完整的表现层解决方案：</p><p>useClassComputed → 负责结构化类名（BEM） useStyleComputed → 负责尺寸、布局等通用内联样式 useColorComputed → 专注颜色与状态（plain、hover、active、disabled）</p><p>通过这一 Hook：</p><p>所有组件的颜色行为高度一致，无需重复编写复杂条件 与主题系统（CSS 变量）深度绑定，切换主题时自动生效 支持自定义颜色与 plain 模式，兼顾灵活性与规范性 状态切换平滑响应式，交互体验统一</p>',15)])])}const m=e(a,[["render",l]]);export{h as __pageData,m as default};
