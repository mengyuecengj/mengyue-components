import{_ as t,o,c as s,ah as d}from"./chunks/framework.BzrxsKI0.js";const u=JSON.parse('{"title":"useClassComputed","description":"","frontmatter":{},"headers":[],"relativePath":"design/hooks/useClass.md","filePath":"design/hooks/useClass.md"}'),a={name:"design/hooks/useClass.md"};function r(l,e,i,n,c,p){return o(),s("div",null,[...e[0]||(e[0]=[d('<h1 id="useclasscomputed" tabindex="-1">useClassComputed <a class="header-anchor" href="#useclasscomputed" aria-label="Permalink to “useClassComputed”">​</a></h1><p>在该组件库的架构中，Hooks 是<strong>逻辑层</strong>的核心承载者。它们不是组件的附属逻辑，而是独立、可复用的抽象单元，负责将重复出现的交互与计算模式彻底从组件中剥离。</p><p>这正是“层分离”思想的直接体现：</p><ul><li><strong>结构层</strong>：仅负责 DOM 布局</li><li><strong>表现层</strong>：仅负责样式注入</li><li><strong>逻辑层</strong>：由 Hooks 统一管理</li></ul><p>Hooks 的存在，让组件实现变得极简——组件只需<strong>声明</strong>所需逻辑，其余响应式计算与驱动全部交给 Hooks 处理。</p><h2 id="动态类名计算-hook" tabindex="-1">动态类名计算 Hook <a class="header-anchor" href="#动态类名计算-hook" aria-label="Permalink to “动态类名计算 Hook”">​</a></h2><h3 id="痛点来源" tabindex="-1">痛点来源 <a class="header-anchor" href="#痛点来源" aria-label="Permalink to “痛点来源”">​</a></h3><p>开发 UI 组件时，最常见的重复工作之一便是根据 props 动态生成类名。例如：</p><ul><li><code>size=&quot;large&quot;</code> → 需要添加 <code>xxx--large</code></li><li><code>disabled={true}</code> → 需要添加 <code>xxx--disabled</code></li><li><code>round={true}</code> → 需要添加 <code>xxx--round</code></li></ul><p>如果每个组件都自行实现此类逻辑，将导致：</p><ul><li>代码高度冗余</li><li>命名规范容易不一致</li><li>可能遗漏响应式更新</li><li>主题或命名规范变更时，需要逐个组件修改，维护成本极高</li></ul><h2 id="设计目标" tabindex="-1">设计目标 <a class="header-anchor" href="#设计目标" aria-label="Permalink to “设计目标”">​</a></h2><p><code>useClassComputed</code> 的目标是：<strong>提供一套统一、类型安全、可配置的机制</strong>，彻底解决所有组件的动态类名生成需求，并将这一逻辑从组件内部完全剥离。</p><h2 id="核心特性" tabindex="-1">核心特性 <a class="header-anchor" href="#核心特性" aria-label="Permalink to “核心特性”">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>响应式输出</strong></td><td>返回 <code>ComputedRef&lt;string[]&gt;</code>，随 props 变化自动更新，完美契合 Vue 响应式系统</td></tr><tr><td><strong>BEM-like 约定</strong></td><td>默认采用 <code>${baseClass}--${modifier}</code> 格式，确保类名语义清晰、可预测</td></tr><tr><td><strong>双轨生成机制</strong></td><td><code>propClasses</code>：针对带值属性（如 <code>size</code>、<code>type</code>）<br><code>flagClasses</code>：针对布尔标志（如 <code>disabled</code>、<code>round</code>）</td></tr><tr><td><strong>高度可定制</strong></td><td>通过 <code>classNameFormatter</code> 支持自定义格式化函数，适应多级 BEM、主题前缀等场景</td></tr><tr><td><strong>类型安全</strong></td><td>泛型 <code>&lt;T&gt;</code> 与组件 props 强绑定，提供完整的 TypeScript 类型推导与提示</td></tr><tr><td><strong>明确边界</strong></td><td>不绑定 DOM、不处理样式冲突、不涉及副作用（如事件监听或 DOM 查询）</td></tr></tbody></table><h2 id="设计价值" tabindex="-1">设计价值 <a class="header-anchor" href="#设计价值" aria-label="Permalink to “设计价值”">​</a></h2><p>useClassComputed 看似简单，却精准解决了组件库中最常见的“样式逻辑耦合”问题。它将类名计算逻辑集中于一处，确保：</p><p>命名规范全局统一 类名生成行为可预测、可配置 组件代码极度精简（无需手动拼接 class） 易于未来演进（如接入主题 token、自动暗黑模式后缀等）</p>',18)])])}const g=t(a,[["render",r]]);export{u as __pageData,g as default};
