import{_ as o,c as e,o as r,ah as d}from"./chunks/framework.D3tsReks.js";const p=JSON.parse('{"title":"useScrollComputed","description":"","frontmatter":{},"headers":[],"relativePath":"design/hooks/useScroll.md","filePath":"design/hooks/useScroll.md"}'),l={name:"design/hooks/useScroll.md"};function a(s,t,c,n,i,h){return r(),e("div",null,[...t[0]||(t[0]=[d('<h1 id="usescrollcomputed" tabindex="-1">useScrollComputed <a class="header-anchor" href="#usescrollcomputed" aria-label="Permalink to “useScrollComputed”">​</a></h1><h3 id="usescrollcomputed-滚动条样式统一管理-hooks" tabindex="-1">useScrollComputed：滚动条样式统一管理 Hooks <a class="header-anchor" href="#usescrollcomputed-滚动条样式统一管理-hooks" aria-label="Permalink to “useScrollComputed：滚动条样式统一管理 Hooks”">​</a></h3><h2 id="痛点来源" tabindex="-1">痛点来源 <a class="header-anchor" href="#痛点来源" aria-label="Permalink to “痛点来源”">​</a></h2><p>原生浏览器滚动条样式差异大、难以统一，且在现代 UI 设计中常常需要自定义外观（颜色、宽度、hover 效果）。常见问题包括：</p><ul><li>全局滚动条样式无法通过普通 CSS 变量直接控制（需作用于 <code>:root</code>）</li><li>不同组件（如 Scrollbar、虚拟列表、容器溢出）对滚动条样式的需求重复</li><li>动态主题切换时，滚动条颜色需实时更新并在组件销毁时清理</li><li>局部滚动条与全局滚动条需求并存（全局影响整个页面，局部仅影响容器）</li><li>宽度/高度单位处理不一致，易遗漏 <code>px</code> 转换</li><li>未清理的全局样式会导致多实例或切换时样式残留、污染</li></ul><p>若每个滚动相关组件都自行处理这些逻辑，会导致样式不统一、清理遗漏、主题适配困难。</p><h2 id="设计目标" tabindex="-1">设计目标 <a class="header-anchor" href="#设计目标" aria-label="Permalink to “设计目标”">​</a></h2><p>本文件提供两套互补的滚动条样式管理方案：</p><ul><li><code>useScrollStyles</code>：<strong>全局滚动条样式控制</strong>，动态注入到 <code>:root</code>，并自动清理</li><li><code>useScrollVariables</code>：<strong>局部滚动条样式控制</strong>，返回 CSS 变量对象，适用于单个容器</li></ul><p>共同目标是：<strong>统一滚动条视觉规范，支持全局与局部双模式，完美适配动态主题与组件生命周期</strong>。</p><h2 id="核心工具对比" tabindex="-1">核心工具对比 <a class="header-anchor" href="#核心工具对比" aria-label="Permalink to “核心工具对比”">​</a></h2><table tabindex="0"><thead><tr><th>Hook</th><th>适用场景</th><th>作用范围</th><th>关键特性</th></tr></thead><tbody><tr><td><strong>useScrollStyles</strong></td><td>需要影响整个页面滚动条（如全局主题）</td><td>全局 <code>:root</code></td><td>自动注入/清理全局变量<br>响应式 <code>ComputedRef</code><br>生命周期安全</td></tr><tr><td><strong>useScrollVariables</strong></td><td>自定义 Scrollbar 容器或局部溢出区域</td><td>局部容器</td><td>纯对象返回，无副作用<br>自动单位处理<br>变量名前缀隔离</td></tr></tbody></table><h2 id="核心特性" tabindex="-1">核心特性 <a class="header-anchor" href="#核心特性" aria-label="Permalink to “核心特性”">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>全局样式自动生命周期管理</strong></td><td><code>onMounted</code> 注入 <code>:root</code> 变量，<code>onUnmounted</code> 自动移除，防止样式泄漏</td></tr><tr><td><strong>响应式局部样式</strong></td><td><code>useScrollStyles</code> 返回 <code>ComputedRef&lt;CSSProperties&gt;</code>，支持 props 变化实时更新</td></tr><tr><td><strong>单位智能处理</strong></td><td><code>scrollWidth</code>/<code>scrollHeight</code> 数字自动加 <code>px</code>，字符串直接透传</td></tr><tr><td><strong>变量名隔离</strong></td><td>局部使用 <code>--scrollbar-container-*</code> 前缀，避免与全局冲突</td></tr><tr><td><strong>全局变量统一</strong></td><td>使用 <code>--global-scroll-*</code> 系列，确保整个库滚动条视觉一致</td></tr><tr><td><strong>SSR 安全</strong></td><td>DOM 操作仅在客户端执行（隐式通过 onMounted/onUnmounted）</td></tr></tbody></table><h2 id="设计价值" tabindex="-1">设计价值 <a class="header-anchor" href="#设计价值" aria-label="Permalink to “设计价值”">​</a></h2><p>这两个工具共同构成了组件库完整的滚动条样式解决方案：</p><p>全局一致性：通过 useScrollStyles 确保所有原生滚动条在主题切换时同步更新 局部灵活性：useScrollVariables 支持独立容器自定义外观 安全可靠：自动清理机制杜绝样式污染，适合动态加载组件 与主题系统无缝衔接：变量名规范、颜色 props 统一 减少重复：所有滚动条相关样式逻辑集中于此，组件无需关心实现细节</p>',17)])])}const b=o(l,[["render",a]]);export{p as __pageData,b as default};
