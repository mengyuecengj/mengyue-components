import{_ as e,c as t,o as r,ah as l}from"./chunks/framework.D3tsReks.js";const p=JSON.parse('{"title":"useColorUtils","description":"","frontmatter":{},"headers":[],"relativePath":"design/hooks/useColorUtils.md","filePath":"design/hooks/useColorUtils.md"}'),a={name:"design/hooks/useColorUtils.md"};function d(i,o,s,c,n,h){return r(),t("div",null,[...o[0]||(o[0]=[l('<h1 id="usecolorutils" tabindex="-1">useColorUtils <a class="header-anchor" href="#usecolorutils" aria-label="Permalink to “useColorUtils”">​</a></h1><h3 id="usecolorutils-颜色工具函数集合" tabindex="-1">useColorUtils：颜色工具函数集合 <a class="header-anchor" href="#usecolorutils-颜色工具函数集合" aria-label="Permalink to “useColorUtils：颜色工具函数集合”">​</a></h3><h2 id="痛点来源" tabindex="-1">痛点来源 <a class="header-anchor" href="#痛点来源" aria-label="Permalink to “痛点来源”">​</a></h2><p>在现代 UI 组件库中，颜色处理是视觉一致性的核心，却常常散落着重复且易出错的逻辑：</p><ul><li>需要将十六进制或 rgb 颜色转换为带透明度的 <code>rgba</code></li><li>主题色或动态颜色需全局注入到 <code>:root</code> 的 CSS 变量中（如 <code>--primary-color</code>）</li><li>朴素（plain）模式下常需对主题变量添加透明度（如 <code>rgba(var(--el-color-primary), 0.2)</code>）</li><li>服务端渲染（SSR）环境下不能访问 <code>document</code>，全局样式注入必须安全处理</li><li>动态注入的全局变量若不清理，会导致内存泄漏或多实例污染</li></ul><p>这些看似简单的需求，若分散在各个组件中实现，会导致转换规则不一致、SSR 报错、样式泄漏等问题。</p><h2 id="设计目标" tabindex="-1">设计目标 <a class="header-anchor" href="#设计目标" aria-label="Permalink to “设计目标”">​</a></h2><p><code>useColorUtils</code> 并非传统意义上的响应式 Hook，而是一个<strong>纯工具函数集合</strong>，专为颜色相关操作提供统一、安全、可复用的实现。它是 <code>useColorComputed</code> 等颜色 Hook 的底层支撑，旨在：</p><ul><li>集中所有颜色转换与全局注入逻辑</li><li>确保 SSR 兼容与客户端安全执行</li><li>提供自动清理机制，避免样式污染</li></ul><h2 id="核心工具函数" tabindex="-1">核心工具函数 <a class="header-anchor" href="#核心工具函数" aria-label="Permalink to “核心工具函数”">​</a></h2><table tabindex="0"><thead><tr><th>函数</th><th>职责</th><th>关键特性</th></tr></thead><tbody><tr><td><strong>toRGBA</strong></td><td>将 <code>#xxx</code>、<code>#xxxxxx</code> 或 <code>rgb()</code> 颜色转换为 <code>rgba(..., opacity)</code></td><td>纯字符串处理，无 DOM 依赖，SSR 完全安全<br>支持 3 位与 6 位 hex<br>异常输入返回 <code>transparent</code></td></tr><tr><td><strong>applyGlobalColor</strong></td><td>将颜色值动态注入到 <code>:root</code> 的 CSS 自定义变量中</td><td>客户端专属（SSR 下自动跳过）<br>使用 <code>onUnmounted</code> 自动清理变量<br>防止多实例或切换时残留旧值</td></tr></tbody></table><h2 id="设计亮点" tabindex="-1">设计亮点 <a class="header-anchor" href="#设计亮点" aria-label="Permalink to “设计亮点”">​</a></h2><ul><li><strong>SSR 友好</strong>：所有涉及 DOM 的操作都严格判断 <code>typeof document !== &#39;undefined&#39;</code>，避免服务端渲染崩溃。</li><li><strong>自动资源管理</strong>：<code>applyGlobalColor</code> 在注入全局变量的同时注册 <code>onUnmounted</code> 清理函数，确保组件销毁时变量被移除，完美适配动态主题切换或多实例场景。</li><li><strong>轻量纯函数</strong>：<code>toRGBA</code> 不依赖 Vue 响应式或生命周期，纯字符串解析，可在任何环境（setup、utils、甚至非 Vue 上下文）安全调用。</li><li><strong>与主题系统深度协同</strong>：专为 CSS 变量（如 <code>var(--btn-color-primary)</code>）设计，配合 <code>toRGBA</code> 可轻松实现透明度叠加效果。</li></ul><h2 id="设计价值" tabindex="-1">设计价值 <a class="header-anchor" href="#设计价值" aria-label="Permalink to “设计价值”">​</a></h2><p>useColorUtils 虽小，却解决了组件库中颜色处理的所有“隐痛”：</p><p>统一转换规则，避免各组件实现差异 安全处理 SSR 与客户端边界 自动清理全局样式，杜绝泄漏 为更高层次的颜色 Hook（如 useColorComputed）提供坚实基础</p>',16)])])}const b=e(a,[["render",d]]);export{p as __pageData,b as default};
