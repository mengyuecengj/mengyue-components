import{_ as o,c as t,o as d,ah as a}from"./chunks/framework.D3tsReks.js";const k=JSON.parse('{"title":"useCheckComputed","description":"","frontmatter":{},"headers":[],"relativePath":"design/hooks/useCheck.md","filePath":"design/hooks/useCheck.md"}'),r={name:"design/hooks/useCheck.md"};function s(c,e,l,i,h,n){return d(),t("div",null,[...e[0]||(e[0]=[a('<h1 id="usecheckcomputed" tabindex="-1">useCheckComputed <a class="header-anchor" href="#usecheckcomputed" aria-label="Permalink to “useCheckComputed”">​</a></h1><h2 id="单选框与复选框专用逻辑-hooks" tabindex="-1">单选框与复选框专用逻辑 Hooks <a class="header-anchor" href="#单选框与复选框专用逻辑-hooks" aria-label="Permalink to “单选框与复选框专用逻辑 Hooks”">​</a></h2><h3 id="痛点来源" tabindex="-1">痛点来源 <a class="header-anchor" href="#痛点来源" aria-label="Permalink to “痛点来源”">​</a></h3><p>单选框（Radio）和复选框（Checkbox）是表单中最常见的交互控件，但它们的实现往往伴随着大量重复逻辑：</p><ul><li>是否选中（checked）的判断逻辑需同时兼容独立使用和 Group 包裹两种场景</li><li>禁用状态需合并组件自身 <code>disabled</code> 与 Group 的 <code>disabled</code></li><li>值变更需正确处理数组（Checkbox）与单一值（Radio）的更新，并触发 <code>update:modelValue</code> 与 <code>change</code> 事件</li><li>与表单组件（如 Form / FormItem）集成时，需要注册字段、重置、清除校验等生命周期管理</li><li>类名状态（如 <code>--checked</code>、<code>--disabled</code>）需响应式更新</li></ul><p>如果每个组件都独立实现这些逻辑，不仅代码冗余，还极易出现行为不一致、边界案例遗漏等问题。</p><h2 id="设计目标" tabindex="-1">设计目标 <a class="header-anchor" href="#设计目标" aria-label="Permalink to “设计目标”">​</a></h2><p><code>useCheckComputed.ts</code> 文件集中封装了所有单选/复选框的通用逻辑，通过多个小型、专注的组合式 Hook，提供一套<strong>统一、可复用、类型安全</strong>的解决方案，让 Radio 和 Checkbox 组件的实现极度精简，同时完美支持：</p><ul><li>独立使用</li><li>Group 包裹使用</li><li>Form / FormItem 集成</li><li>v-model 双向绑定</li></ul><h2 id="核心-hooks-组成" tabindex="-1">核心 Hooks 组成 <a class="header-anchor" href="#核心-hooks-组成" aria-label="Permalink to “核心 Hooks 组成”">​</a></h2><table tabindex="0"><thead><tr><th>Hook</th><th>职责</th><th>关键特性</th></tr></thead><tbody><tr><td><strong>useFormField</strong></td><td>处理与 FormItem 的字段注册、重置、校验清除</td><td>自动 onMounted 注册 / onBeforeUnmount 注销，支持 resetField</td></tr><tr><td><strong>useInputState</strong></td><td>计算 <code>isChecked</code> 和 <code>isDisabled</code> 状态，兼容 Group 与独立模式</td><td>优先使用 Group 的 modelValue/disabled，支持数组与单一值比较</td></tr><tr><td><strong>useInputClasses</strong></td><td>根据选中/禁用状态生成响应式类名数组</td><td>简洁、可复用，支持自定义前缀（如 <code>my-radio</code>、<code>my-checkbox</code>）</td></tr><tr><td><strong>useInputChange</strong></td><td>处理 change 事件，正确更新 modelValue（数组或单一值）并触发事件</td><td>区分 Checkbox（数组操作）和 Radio（直接赋值），防止禁用时触发</td></tr></tbody></table><h2 id="设计亮点" tabindex="-1">设计亮点 <a class="header-anchor" href="#设计亮点" aria-label="Permalink to “设计亮点”">​</a></h2><ul><li><strong>完美的 Group 兼容性</strong>：通过 <code>inject</code> 获取 <code>radioGroup</code> 或 <code>checkboxGroup</code> 上下文，所有状态与变更逻辑优先走 Group，避免重复实现。</li><li><strong>类型安全泛型设计</strong>：<code>GroupContext&lt;M&gt;</code> 支持任意 modelValue 类型，<code>useInputState</code> 和 <code>useInputChange</code> 通过泛型精确推导 Radio（单一值）与 Checkbox（数组）的差异。</li><li><strong>最小侵入性</strong>：每个 Hook 职责单一，组件只需按需组合使用，无需关心底层实现细节。</li><li><strong>与表单系统深度集成</strong>：自动处理字段注册与重置，配合 FormItem 的校验与 reset 功能，无需额外代码。</li><li><strong>边界处理严谨</strong>：禁用时阻止变更、值比较使用 <code>String()</code> 避免类型陷阱、数组操作使用展开避免引用问题。</li></ul><h2 id="设计价值" tabindex="-1">设计价值 <a class="header-anchor" href="#设计价值" aria-label="Permalink to “设计价值”">​</a></h2><p>useCheckComputed 将原本分散在 Radio 和 Checkbox 中的复杂状态管理、事件处理、表单集成逻辑，统一抽象为四个小型、可组合的 Hook，实现了：</p><p>行为高度一致（独立与 Group 模式无缝切换） 代码极简（组件逻辑不到 30 行） 易于维护与扩展（新增功能只需在此文件增强） 与组件库其他系统（如 Form、Class/Style Hooks）完美协同</p>',16)])])}const p=o(r,[["render",s]]);export{k as __pageData,p as default};
